// src/features/pronunciation/hooks/useAudioAnalysis.ts
// Ïò§ÎîîÏò§ Î∂ÑÏÑù ÌõÖ
// initializeAudio() ‚Üí analyzeWaveform() ‚Üí analyzePitch() ‚Üí analyzeSpectrogram() ‚Üí analyzeCER() ‚Üí calculateFinalScore()

import { useCallback, useRef } from "react";
import WaveSurfer from "wavesurfer.js";
import Pitchfinder from "pitchfinder";
import { usePronunciationStore } from "@/store/pronunciationStore";
import { useScoreStore } from "@/store/scoreStore";
import { ANALYSIS_STEPS ,CER_PRESETS} from "@/types/pronunciation";

import {
  toMono,
  downsample,

  maxNormalizedCrossCorr,
  calculateRMSPattern,
  calculatePeakAmplitudeScore,
  analyzePitchPattern,
  calculateCER,
} from "@/utils/audioAnalysis";

export function useAudioAnalysis() {
  const {
    currentContext,
    recordedAudioBlob,
    sttTranscript,
  } = usePronunciationStore();

  const {
    updateAnalysisProgress,
    setWaveformAnalysis,
    setPitchAnalysis,
    setSpectrogramAnalysis,
    setAnalysisResult,
  } = useScoreStore();

  const refWavesurferRef = useRef<WaveSurfer | null>(null);
  const userWavesurferRef = useRef<WaveSurfer | null>(null);

  //ANCHOR 1. WaveSurfer Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Î∞è Ïò§ÎîîÏò§ Î°úÎìú
  const initializeAudio = useCallback(async () => {
    updateAnalysisProgress(ANALYSIS_STEPS.LOADING_AUDIO, 10);
    await new Promise((resolve) => setTimeout(resolve, 100)); // 1Ï¥à ÎîúÎ†àÏù¥

    // ÌëúÏ§Ä ÏùåÏÑ± WaveSurfer
    const refContainer = document.createElement("div");
    refContainer.style.display = "none";
    document.body.appendChild(refContainer);

    const refWavesurfer = WaveSurfer.create({
      container: refContainer,
      waveColor: "transparent",
      progressColor: "transparent",
      url:
        currentContext?.audioReference ||
        "/src/assets/audio/references/Default.wav",
      sampleRate: 11025,
    });

    // ÏÇ¨Ïö©Ïûê ÏùåÏÑ± WaveSurfer
    const userContainer = document.createElement("div");
    userContainer.style.display = "none";
    document.body.appendChild(userContainer);

    const userBlobUrl = URL.createObjectURL(recordedAudioBlob!);
    const userWavesurfer = WaveSurfer.create({
      container: userContainer,
      waveColor: "transparent",
      progressColor: "transparent",
      url: userBlobUrl,
      sampleRate: 11025,
    });

    // Ready Ïù¥Î≤§Ìä∏ ÎåÄÍ∏∞
    await Promise.all([
      new Promise((resolve) => refWavesurfer.once("ready", resolve)),
      new Promise((resolve) => userWavesurfer.once("ready", resolve)),
    ]);

    refWavesurferRef.current = refWavesurfer;
    userWavesurferRef.current = userWavesurfer;

    // ÌÅ¥Î¶∞ÏóÖ
    URL.revokeObjectURL(userBlobUrl);

    updateAnalysisProgress(ANALYSIS_STEPS.LOADING_COMPLETE, 20);

    return { refWavesurfer, userWavesurfer };
  }, [currentContext, recordedAudioBlob, updateAnalysisProgress]);

  //ANCHOR 2. Waveform Î∂ÑÏÑù
  const analyzeWaveform = useCallback(async () => {
    updateAnalysisProgress(ANALYSIS_STEPS.ANALYZING_WAVEFORM, 30);
    await new Promise((resolve) => setTimeout(resolve, 100)); // 1Ï¥à ÎîúÎ†àÏù¥

    const refWavesurfer = refWavesurferRef.current;
    const userWavesurfer = userWavesurferRef.current;

    if (!refWavesurfer || !userWavesurfer) {
      throw new Error("WaveSurfer not initialized");
    }

    const refBuffer = refWavesurfer.getDecodedData();
    const userBuffer = userWavesurfer.getDecodedData();

    if (!refBuffer || !userBuffer) {
      throw new Error("Failed to get audio buffers");
    }

    // PCM Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
    const refPCM = toMono(refBuffer);
    const userPCM = toMono(userBuffer);

    //NOTE  NCC Í≥ÑÏÇ∞
    const refDownsampled = downsample(refPCM, refBuffer.sampleRate, 4000);
    const userDownsampled = downsample(userPCM, userBuffer.sampleRate, 4000);
    const nccScore = maxNormalizedCrossCorr(
      refDownsampled,
      userDownsampled,
      4000,
      0.5
    );

    //NOTE RMS Ìå®ÌÑ¥ Î∂ÑÏÑù
    const rmsResult = calculateRMSPattern(refPCM, userPCM, 10);

    //NOTE Peaks Îç∞Ïù¥ÌÑ∞
    const refPeaks = refWavesurfer.exportPeaks();
    const userPeaks = userWavesurfer.exportPeaks();
    const peakResult = calculatePeakAmplitudeScore(refPeaks, userPeaks);

 //NOTE ÏµúÏ¢Ö Waveform Ï†êÏàò (NCC + RMS + Peak)
 const combinedScore = (
  nccScore * 0.35 +           // NCC 35%
  rmsResult.averageScore * 0.35 + // RMS 35%
  peakResult.peakScore * 0.3      // Peak 30%
) * 100;

    console.log("üìäüìäüìäüìäüìäüìäüìäüìäüìäüìä Waveform Ï¢ÖÌï© Î∂ÑÏÑù:", {
      NCC: (nccScore * 100).toFixed(1),
      RMS: (rmsResult.averageScore * 100).toFixed(1),
      Peak: (peakResult.peakScore * 100).toFixed(1),
      // Combined: combinedScore.toFixed(1),
      Combined: (nccScore * 100).toFixed(1)
    });


    setWaveformAnalysis({
      refPCMData: refPCM,
      userPCMData: userPCM,
      refPeaks,
      userPeaks,
      nccScore,
      rmsScore: rmsResult.averageScore,
      segmentScores: rmsResult.segmentScores,
    });

    updateAnalysisProgress(ANALYSIS_STEPS.WAVEFORM_COMPLETE, 40);

    return {
      nccScore,
      rmsScore: rmsResult.averageScore,
      combinedScore: (nccScore * 0.5 + Math.max(rmsResult.averageScore, peakResult.peakScore) * 0.5) * 100,
    };
  }, [setWaveformAnalysis, updateAnalysisProgress]);

  //ANCHOR 3. Pitch Î∂ÑÏÑù
  const analyzePitch = useCallback(async () => {
    updateAnalysisProgress(ANALYSIS_STEPS.ANALYZING_PITCH, 50);
    await new Promise((resolve) => setTimeout(resolve, 100)); // 1Ï¥à ÎîúÎ†àÏù¥

    const refWavesurfer = refWavesurferRef.current;
    const userWavesurfer = userWavesurferRef.current;

    if (!refWavesurfer || !userWavesurfer) {
      throw new Error("WaveSurfer not initialized");
    }

    const refBuffer = refWavesurfer.getDecodedData();
    const userBuffer = userWavesurfer.getDecodedData();

    if (!refBuffer || !userBuffer) {
      throw new Error("Failed to get audio buffers");
    }

    // PitchfinderÎ°ú Ï£ºÌååÏàò Ï∂îÏ∂ú
    const refPCM = refBuffer.getChannelData(0);
    const userPCM = userBuffer.getChannelData(0);
    const sampleRate = 11025;

    const detectPitch = Pitchfinder.AMDF({ sampleRate });
    const refFrequencies = Pitchfinder.frequencies(detectPitch, refPCM, {
      tempo: 120,
      quantization: 120,
    });
    const userFrequencies = Pitchfinder.frequencies(detectPitch, userPCM, {
      tempo: 120,
      quantization: 120,
    });

    // Base frequency Í≥ÑÏÇ∞
    const calculateBaseFrequency = (frequencies: (number | null)[]) => {
      const freqMap: { [key: number]: number } = {};
      let maxCount = 0;
      let baseFreq = 0;

      frequencies.forEach((f) => {
        if (!f) return;
        const rounded = Math.round(f * 10) / 10;
        freqMap[rounded] = (freqMap[rounded] || 0) + 1;
        if (freqMap[rounded] > maxCount) {
          maxCount = freqMap[rounded];
          baseFreq = rounded;
        }
      });

      return baseFreq;
    };

    const refBase = calculateBaseFrequency(refFrequencies);
    const userBase = calculateBaseFrequency(userFrequencies);

    // ÌèâÍ∑† ÌîºÏπò
    const validRef = refFrequencies.filter(
      (f) => f !== null && f > 0
    ) as number[];
    const validUser = userFrequencies.filter(
      (f) => f !== null && f > 0
    ) as number[];

    const refAvg = validRef.reduce((a, b) => a + b, 0) / validRef.length;
    const userAvg = validUser.reduce((a, b) => a + b, 0) / validUser.length;

    // Ìå®ÌÑ¥ Îß§Ïπ≠ Ï†êÏàò
    const patternResult = analyzePitchPattern(refFrequencies, userFrequencies);

    setPitchAnalysis({
      refFrequencies,
      userFrequencies,
      refBaseFrequency: refBase,
      userBaseFrequency: userBase,
      refAveragePitch: refAvg,
      userAveragePitch: userAvg,
      patternMatchScore: patternResult.patternScore,
    });

    updateAnalysisProgress(ANALYSIS_STEPS.PITCH_COMPLETE, 60);

    return {
      patternScore: patternResult.patternScore * 100,
      averageDifference: Math.abs(refAvg - userAvg),
      similarity: Math.max(
        0,
        100 - (Math.abs(refAvg - userAvg) / refAvg) * 100
      ),
    };
  }, [setPitchAnalysis, updateAnalysisProgress]);

  // 4. Spectrogram Î∂ÑÏÑù (Í∞ÑÏÜåÌôî)
  const analyzeSpectrogram = useCallback(async () => {
    updateAnalysisProgress(ANALYSIS_STEPS.ANALYZING_SPECTRUM, 70);

    const refWavesurfer = refWavesurferRef.current;
    const userWavesurfer = userWavesurferRef.current;

    if (!refWavesurfer || !userWavesurfer) {
      throw new Error("WaveSurfer not initialized");
    }

    const refBuffer = refWavesurfer.getDecodedData();
    const userBuffer = userWavesurfer.getDecodedData();

    // Ï£ºÌååÏàò ÎåÄÏó≠Î≥Ñ ÏóêÎÑàÏßÄ Í≥ÑÏÇ∞ (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
    const calculateBandEnergy = (buffer: AudioBuffer) => {
      const data = buffer.getChannelData(0);
      const bandCount = 4;
      const bandEnergies = [];

      for (let i = 0; i < bandCount; i++) {
        const start = Math.floor((i * data.length) / bandCount);
        const end = Math.floor(((i + 1) * data.length) / bandCount);
        const segment = data.slice(start, end);
        const energy = Math.sqrt(
          segment.reduce((sum, x) => sum + x * x, 0) / segment.length
        );
        bandEnergies.push(energy);
      }

      return bandEnergies;
    };

    const refBands = calculateBandEnergy(refBuffer!);
    const userBands = calculateBandEnergy(userBuffer!);

    // ÎåÄÏó≠Î≥Ñ Ïú†ÏÇ¨ÎèÑ
    const bandScores = refBands.map((refEnergy, i) => {
      const userEnergy = userBands[i];
      return (
        Math.min(refEnergy, userEnergy) / Math.max(refEnergy, userEnergy, 0.001)
      );
    });

    setSpectrogramAnalysis({
      refSpectrogramData: null, // Ïã§Ï†ú Ïä§ÌéôÌä∏Î°úÍ∑∏Îû® Îç∞Ïù¥ÌÑ∞Îäî ÌîåÎü¨Í∑∏Ïù∏ÏóêÏÑú Í¥ÄÎ¶¨
      userSpectrogramData: null,
      frequencyBandScores: bandScores,
      mfccScore: bandScores.reduce((a, b) => a + b, 0) / bandScores.length,
    });

    updateAnalysisProgress(ANALYSIS_STEPS.SPECTRUM_COMPLETE, 80);

    return {
      bandScores,
      averageScore:
        (bandScores.reduce((a, b) => a + b, 0) / bandScores.length) * 100,
    };
  }, [setSpectrogramAnalysis, updateAnalysisProgress]);


   //ANCHOR 5. CER Î∂ÑÏÑù (ÏÉàÎ°ú Î∂ÑÎ¶¨Îêú Ìï®Ïàò)
   const analyzeCER = useCallback(async () => {
    updateAnalysisProgress(ANALYSIS_STEPS.CALCULATING_SCORE, 85);
    await new Promise((resolve) => setTimeout(resolve, 100));

    let cerScore = 0; // Í∏∞Î≥∏Í∞í (STT Í≤∞Í≥ºÍ∞Ä ÏóÜÏùÑ Í≤ΩÏö∞)
    let cerResult = null;

    if (sttTranscript && currentContext?.text) {
      const cerConfig = CER_PRESETS.default;
      cerResult = calculateCER(
        currentContext.text,
        sttTranscript,
        cerConfig
      );
      
      // semanticScore ÏÇ¨Ïö©
      cerScore = cerResult.semanticScore;
      
      console.log('üìä CER Î∂ÑÏÑù Í≤∞Í≥º:', {
        ÏõêÎ≥∏: currentContext.text,
        STT: sttTranscript,
        Ï†êÏàò: cerScore,
        ÏÉÅÏÑ∏: cerResult
      });
    } else {
      console.log('‚ö†Ô∏è STT Í≤∞Í≥º ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©');
    }

  

    updateAnalysisProgress(ANALYSIS_STEPS.CALCULATING_SCORE, 90);

    return {
      cerScore,
      accuracy: cerResult?.accuracy || 1.0,
      errors: cerResult?.errors || 0,
      hasSTTResult: !!(sttTranscript && currentContext?.text)
    };
  }, [sttTranscript, currentContext, updateAnalysisProgress]);


  // 5. ÏµúÏ¢Ö Ï†êÏàò Í≥ÑÏÇ∞
  const calculateFinalScore = useCallback(
    async (
      waveformScore: number,
      pitchScore: number,
      spectrogramScore: number,
      cerScore: number
    ) => {
      updateAnalysisProgress(ANALYSIS_STEPS.CALCULATING_SCORE, 90);
      await new Promise((resolve) => setTimeout(resolve, 300)); // 0.3Ï¥à ÎîúÎ†àÏù¥

      // Í∞ÄÏ§ë ÌèâÍ∑†
      const weights = {
        waveform: 0.2,    // 30% - ÏßÑÌè≠ Ïú†ÏÇ¨ÎèÑ
        pitch: 0.2,       // 20% - ÌîºÏπò Ìå®ÌÑ¥
        spectrogram: 0.0, // 10% - Ï£ºÌååÏàò Î∂ÑÏÑù
        cer: 0.5,         // 40% - ÌÖçÏä§Ìä∏ Ï†ïÌôïÎèÑ
      };

      const totalScore = Math.round(
        waveformScore * weights.waveform +
          pitchScore * weights.pitch +
          spectrogramScore * weights.spectrogram +
          cerScore * weights.cer
      );

      const totalWaveformObj = {
        "waveformScore" :waveformScore,
        "weights.waveform":weights.waveform,
        "waveformScore * weights.waveform":waveformScore * weights.waveform,
      }

      const pitchScoreObj = {
        "pitchScore" :pitchScore,
        "weights.pitch":weights.pitch,
        "pitchScore * weights.pitch":pitchScore * weights.pitch,
        }

      const spectrogramScoreObj = {
        "spectrogramScore" :spectrogramScore,
        "weights.spectrogram":weights.spectrogram,
        "spectrogramScore * weights.spectrogram":spectrogramScore * weights.spectrogram,
        }
        
      const cerScoreObj = {
        "cerScore" :cerScore,
        "weights.cer":weights.cer,
        "cerScore * weights.cer":cerScore * weights.cer,
        }
        
        
      console.log("üîçüîçüîç totalScore : ", totalScore);
      console.log("üîçüîçüîç waveformScore * weights.waveform : " , totalWaveformObj);
      console.log("üîçüîçüîç pitchScore * weights.pitch : ", pitchScoreObj);
      console.log("üîçüîçüîç spectrogramScore * weights.spectrogram : ",spectrogramScoreObj );
      console.log("üîçüîçüîç cerScore * weights.cer : ", cerScoreObj);

      // ÌîºÎìúÎ∞± ÏÉùÏÑ±
      const feedback = [];
      if (waveformScore < 70)
        feedback.push("Î∞úÌôî Í∞ïÎèÑÏôÄ Î¶¨Îì¨ÏùÑ Îçî Ïó∞ÏäµÌï¥Î≥¥ÏÑ∏Ïöî");
      if (pitchScore < 70)
        feedback.push("ÏùåÏ†ï Ìå®ÌÑ¥ÏùÑ Îçî Ï†ïÌôïÌïòÍ≤å Îî∞ÎùºÌï¥Î≥¥ÏÑ∏Ïöî");
      if (spectrogramScore < 70) feedback.push("Î∞úÏùåÏùÑ Îçî Î™ÖÌôïÌïòÍ≤å Ìï¥Î≥¥ÏÑ∏Ïöî");

      setAnalysisResult({
        totalScore,
        waveformScore: Math.round(waveformScore),
        pitchScore: Math.round(pitchScore),
        spectrogramScore: Math.round(spectrogramScore),
        cerScore,
        feedback,
      });

      updateAnalysisProgress(ANALYSIS_STEPS.ANALYSIS_COMPLETE, 100);

      return { totalScore };
    },
    [setAnalysisResult, updateAnalysisProgress]
  );

  // 6. Ï†ÑÏ≤¥ Î∂ÑÏÑù Ïã§Ìñâ
  /**
   * @description  initializeAudio() ‚Üí analyzeWaveform() ‚Üí analyzePitch() ‚Üí analyzeSpectrogram() ‚Üí calculateFinalScore()
   * @returns {Promise<{ totalScore: number }>} ÏµúÏ¢Ö Ï†êÏàò
   */
  const runFullAnalysis = useCallback(async () => {
    try {
      // Ï¥àÍ∏∞Ìôî
      await initializeAudio();

      // Í∞Å Î∂ÑÏÑù Ïã§Ìñâ
      const waveformResult = await analyzeWaveform();
      const pitchResult = await analyzePitch();
      const spectrogramResult = await analyzeSpectrogram();
      const cerResult = await analyzeCER();
      // ÏµúÏ¢Ö Ï†êÏàò Í≥ÑÏÇ∞
      const finalResult = await calculateFinalScore(
        waveformResult.combinedScore,
        pitchResult.patternScore,
        spectrogramResult.averageScore,
        cerResult.cerScore
      );

      // ÌÅ¥Î¶∞ÏóÖ
      if (refWavesurferRef.current) {
        refWavesurferRef.current.destroy();
        refWavesurferRef.current = null;
      }
      if (userWavesurferRef.current) {
        userWavesurferRef.current.destroy();
        userWavesurferRef.current = null;
      }

      // ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏
      console.log("=============üé´ ÏµúÏ¢Ö Ï†êÏàò Í≥ÑÏÇ∞ ÏãúÏûë====================");
      console.log("waveformResult", waveformResult);
      console.log("pitchResult", pitchResult);
      console.log("spectrogramResult", spectrogramResult);
      console.log("finalResult", finalResult);
      console.log("üí©üí©üí© waveformResult.combinedScore", waveformResult.combinedScore);
      console.log("üí©üí©üí© pitchResult.patternScore", pitchResult.patternScore);
      console.log("üí©üí©üí© spectrogramResult.averageScore", spectrogramResult.averageScore);
      console.log("üí©üí©üí© cerResult.cerScore", cerResult.cerScore);
      console.log("=====================================================");

      return finalResult;
    } catch (error) {
      console.error("Analysis failed:", error);
      throw error;
    }
  }, [
    initializeAudio,
    analyzeWaveform,
    analyzePitch,
    analyzeSpectrogram,
    analyzeCER,
    calculateFinalScore,
  ]);

  return {
    runFullAnalysis,
  };
}
